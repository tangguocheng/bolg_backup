{"meta":{"title":"树下石","subtitle":"不积跬步，无以至千里。<br/>不积小流，无以成江海。","description":"曾经沧海难为水，除却巫山不是云","author":"tanggc`s blog","url":"http://www.xn--4gqa63c686ta68iba.ren"},"pages":[{"title":"","date":"2016-11-30T01:45:06.385Z","updated":"2016-08-17T03:40:58.472Z","comments":true,"path":"404.html","permalink":"http://www.xn--4gqa63c686ta68iba.ren/404.html","excerpt":"","text":"404"},{"title":"关于本站","date":"2016-08-17T13:42:24.000Z","updated":"2016-12-12T11:30:23.063Z","comments":true,"path":"about/index.html","permalink":"http://www.xn--4gqa63c686ta68iba.ren/about/index.html","excerpt":"","text":"这个站点的创立初衷是送给我那温柔大方、美丽动人的女朋友的儿童节礼物。改版之前的首页 同时自己也有一个写博客记录以及激励自己的想法，因此将站点改成了个人博客。博客使用 Hexo + GitHub Pages 搭建，网站样式修改自主题 maupassant ，在此感谢原作者的开源奉献。 作者本人从事单片机软件开发，有三年多的固件开发经验，目前工作在消费类电子领域，主要从事智能机器人的底层驱动软件设计与开发。对物联网与智能家居有很大的兴趣，接下来会向这个方向发展。"},{"title":"categories","date":"2016-11-30T10:51:39.000Z","updated":"2016-11-30T02:52:04.132Z","comments":false,"path":"categories/index.html","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/index.html","excerpt":"","text":""},{"title":"给最爱的你","date":"2016-08-17T13:42:34.000Z","updated":"2017-01-10T01:47:45.068Z","comments":true,"path":"holiday/index.html","permalink":"http://www.xn--4gqa63c686ta68iba.ren/holiday/index.html","excerpt":"","text":"function isHoliday() { var today = new Date(); var holiday = {'1/1':'元旦','3/8':'妇女节','5/1':'劳动节','6/1':'儿童节','8/9':'七夕','9/15':'中秋','10/1':'国庆节','12/25':'圣诞节'}; var key = (today.getMonth() + 1) + '/' + today.getDate(); if (holiday[key]) { var rtl = confirm(\"今天是\"+holiday[key]+\",是否跳转到节日页面^_^\"); if (rtl) { switch(holiday[key]) { case '儿童节': window.location.assign(\"http://www.xn--4gqa63c686ta68iba.ren/day/ertongjie/2016/index.html\"); break; case '七夕': window.location.assign(\"http://www.xn--4gqa63c686ta68iba.ren/day/qixi/2016/index.html\"); break; case '中秋': window.location.assign(\"http://www.xn--4gqa63c686ta68iba.ren/day/zhongqiu/2016/index.html\"); break; default: //confirm(\"今天是\"+holiday[key]+\",是否跳转到节日页面^_^\"); break; } } } } function timeMsg() { setTimeout(\"isHoliday()\", 2000); } timeMsg(); 2016儿童节 七夕 中秋"},{"title":"tags","date":"2016-11-30T10:50:13.000Z","updated":"2016-11-30T02:51:18.213Z","comments":false,"path":"tags/index.html","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STM32模拟I2C读取BQ34Z100","slug":"SMT32_I2C","date":"2017-03-14T15:18:21.000Z","updated":"2017-03-14T08:00:36.000Z","comments":true,"path":"2017/03/14/SMT32_I2C/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2017/03/14/SMT32_I2C/","excerpt":"","text":"总线拉低使用开漏输出、拉高配置为浮动输入以释放总线。同时因为此时为输入模式，ACK的检测可以很方便做到。 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352#include &lt;stdio.h&gt;#include \"stm32f10x.h\"#include \"battery_manage.h\"#include \"delay.h\"static battery_t battery_1;static battery_t battery_2;static GPIO_TypeDef* BQ34Z100_GPIO_SCL;static uint16_t BQ34Z100_SCL_pin;static GPIO_TypeDef* BQ34Z100_GPIO_SDA;static uint16_t BQ34Z100_SDA_pin;/** * @brief BQ34Z100 字节转u16 * @param u8* data 字节指针 * @return NONE */static inline u16 bytes_to_integer(u8* data)&#123; u16 tmp; tmp = ((data[1] &lt;&lt; 8) &amp; 0xFF00); return ((u16)(tmp + data[0]) &amp; 0x0000FFFF);&#125;/** * @brief BQ34Z100 IO配置 * @param IO参数 * @return NONE */void bq34z100_io_config(GPIO_TypeDef* GPIO_SCL, uint16_t SCL_pin, GPIO_TypeDef* GPIO_SDA, uint16_t SDA_pin)&#123; BQ34Z100_GPIO_SCL = GPIO_SCL; BQ34Z100_SCL_pin = SCL_pin; BQ34Z100_GPIO_SDA = GPIO_SDA; BQ34Z100_SDA_pin = SDA_pin;&#125;/** * @brief BQ34Z100 I2C起始信号 * @param NONE * @return NONE */void bq34z100_i2c_start(void)&#123; SDA_1(); I2CDELAY(); SCL_1(); I2CDELAY(); SDA_0(); I2CDELAY(); SCL_0(); I2CDELAY();&#125;/** * @brief BQ34Z100 I2C停止信号 * @param NONE * @return NONE */void bq34z100_i2c_stop(void)&#123; SDA_0(); I2CDELAY(); SCL_1(); I2CDELAY(); SDA_1(); I2CDELAY();&#125;/** * @brief BQ34Z100 I2C发送字节 * @param u8 data 发送数据 * @return ACK */u8 bq34z100_i2c_send_byte(u8 data)&#123; u8 bits, temp, ack; u16 wait_cnt; SCL_0(); temp = data; bits = 0x08; while (bits != 0x00) &#123; if (temp &amp; 0x80) SDA_1(); else SDA_0(); I2CDELAY(); SCL_1(); wait_cnt = 0; while ((BQ34Z100_GPIO_SCL-&gt;IDR &amp; BQ34Z100_SCL_pin) == 0) &#123; wait_cnt++; if (wait_cnt &gt; 200) &#123; bq34z100_i2c_stop(); return (0); &#125; &#125; I2CDELAY(); temp = (temp &lt;&lt; 1); SCL_0(); bits = (bits - 1); &#125; I2CDELAY(); SDA_1(); SCL_1(); wait_cnt = 0; while ((BQ34Z100_GPIO_SCL-&gt;IDR &amp; BQ34Z100_SCL_pin) == 0) &#123; wait_cnt++; if (wait_cnt &gt; 200) &#123; bq34z100_i2c_stop(); return (0); &#125; &#125; I2CDELAY(); ack = (((BQ34Z100_GPIO_SDA-&gt;IDR &amp; BQ34Z100_SDA_pin) == 0) ? 0 : 1); SCL_0(); if (ack) return (1); else return (0);&#125;/** * @brief BQ34Z100 I2C接收字节 * @param u8 ack 是否响应ACK * @return u8 data 接收数据 */u8 bq34z100_i2c_rev_byte(u8 ack)&#123; u8 bits, data = 0; SDA_1(); bits = 0x08; while (bits &gt; 0) &#123; SCL_1(); while ((BQ34Z100_GPIO_SCL-&gt;IDR &amp; BQ34Z100_SCL_pin) == 0) I2CDELAY(); data = (data &lt;&lt; 1); if (BQ34Z100_GPIO_SDA-&gt;IDR &amp; BQ34Z100_SDA_pin) data = (data + 1); SCL_0(); I2CDELAY(); bits = (bits - 1); &#125; if (ack) SDA_0(); else SDA_1(); SCL_1(); I2CDELAY(); SCL_0(); SDA_1(); return (data);&#125;/** * @brief BQ34Z100 写入数据块 * @param u8 SlaveAddress 设备地址 * @param u16 numBytes 读取字节 * @param void* rx_data 数据指针 * @param unsigned char multi 是否多数据帧 * @return NONE */void bq34z100_i2c_write_block(u8 SlaveAddress, u16 numBytes, u8 multi, void* TxData)&#123; u16 i; u8* temp; temp = (u8*)TxData; bq34z100_i2c_start(); bq34z100_i2c_send_byte(SlaveAddress + 0); for (i = 0; i &lt; numBytes; i++) &#123; bq34z100_i2c_send_byte(*(temp)); temp++; &#125; if (multi == 0) &#123; bq34z100_i2c_stop(); &#125; I2CDELAY();&#125;/** * @brief BQ34Z100 读取数据块 * @param u8 SlaveAddress 设备地址 * @param u16 numBytes 读取字节 * @param void* rx_data 数据指针 * @return NONE */void bq34z100_i2c_read_block(u8 SlaveAddress, u16 numBytes, void* rx_data)&#123; u16 i; u8* temp; temp = (u8*)rx_data; bq34z100_i2c_start(); bq34z100_i2c_send_byte(SlaveAddress + 1); for (i = 0; i &lt; numBytes; i++) &#123; if (i == (numBytes - 1)) *(temp) = bq34z100_i2c_rev_byte(BQ34Z100_NACK); else *(temp) = bq34z100_i2c_rev_byte(BQ34Z100_ACK); temp++; &#125; bq34z100_i2c_stop();&#125;/** * @brief BQ34Z100 i2c初始化 * @param NONE * @return NONE */void bq34z100_i2c_init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = BQ34Z100_SDA_pin; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(BQ34Z100_GPIO_SDA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = BQ34Z100_SCL_pin; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(BQ34Z100_GPIO_SCL, &amp;GPIO_InitStructure);&#125;/** * @brief BQ34Z100寄存器读取 * @param u8 port_switch 端口选择 1：电池1,2：电池2 * @param u16 bytes 读取字节 * @param void* rx_data 数据指针 * @return NONE */void bq34z100_read_reg(u8 port_switch, u8 cmd, u16 bytes, void* rx_data)&#123; u8 tx[1]; tx[0] = cmd; if (port_switch == 1) &#123; bq34z100_io_config(BATTERY_1_I2C_SCL_GPIO, BATTERY_1_I2C_SCL_PIN, BATTERY_1_I2C_SDA_GPIO, BATTERY_1_I2C_SDA_PIN); &#125; else if (port_switch == 2) &#123; bq34z100_io_config(BATTERY_2_I2C_SCL_GPIO, BATTERY_2_I2C_SCL_PIN, BATTERY_2_I2C_SDA_GPIO, BATTERY_2_I2C_SDA_PIN); &#125; else &#123; return; &#125; bq34z100_i2c_init(); delay_nus(200); bq34z100_i2c_write_block(BQ34Z100_ADDR, 1, 1, tx); bq34z100_i2c_read_block(BQ34Z100_ADDR, bytes, rx_data);&#125;/** * @brief BQ34Z100 状态标识处理 * @param u8 battery_num 电池号 * @return NONE */void bq34z100_flag_process(u8 battery_num)&#123;&#125;/** * @brief BQ34Z100信息读取 * @param u8 battery_num 电池号 * @return NONE */void BQ34Z100_get_charge_state(u8 battery_num)&#123; u8 tmp[2]; static u8 step[2] = &#123;0, 0&#125;; battery_t* battery; if (battery_num == 1) battery = &amp;battery_1; else if (battery_num == 2) battery = &amp;battery_2; else return; switch (step[battery_num - 1]) &#123; case 0: // 温度 K bq34z100_read_reg(battery_num, BQ34Z100_TEMPERATURE_LSB, 2, tmp); battery-&gt;temperature = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"temperature:%d\\n\\n\", (battery-&gt;temperature - 2731) / 10); break; case 1: // 电量百分比 0-100% bq34z100_read_reg(battery_num, BQ34Z100_STATE_OF_CHARGE, 1, tmp); battery-&gt;charge_state = tmp[0]; printf(\"[%d] \", battery_num); printf(\"Percentage of electricity:%d \\n\\n\", battery-&gt;charge_state); break; case 2: // 电池容量 mAh (充满电之后校准) bq34z100_read_reg(battery_num, BQ34Z100_FULL_CHAGRE_CAP_LSB, 2, tmp); battery-&gt;full_charge_cap = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"total capacity:%d mAh \\n\\n\", battery-&gt;full_charge_cap); break; case 3: // 剩余电池容量 * 1 mAh bq34z100_read_reg(battery_num, BQ34Z100_REMAIN_CAP_LSB, 2, tmp); battery-&gt;remain_cap = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"remain capacity:%d mAh \\n\\n\", battery-&gt;remain_cap); break; case 4: // 电压 mV bq34z100_read_reg(battery_num, BQ34Z100_VOLTAGE_LSB, 2, tmp); battery-&gt;voltage = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"voltage:%d mV \\n\\n\", battery-&gt;voltage); break; case 5: // 电流 mA bq34z100_read_reg(battery_num, BQ34Z100_CURRENT_LSB, 2, tmp); battery-&gt;current = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"current:%d mA \\n\\n\", battery-&gt;current); break; case 6: // 运行标志 bq34z100_read_reg(battery_num, BQ34Z100_FLAGS_LSB, 2, tmp); battery-&gt;flag = bytes_to_integer(tmp); printf(\"[%d] \", battery_num); printf(\"run flag:%x \\n\\n\", battery-&gt;flag); break; default: break; &#125; (step[battery_num - 1] &gt; 6) ? (step[battery_num - 1] = 0) : step[battery_num - 1]++; &#125; 头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#ifndef _BATTERY_MANAGE_H#define _BATTERY_MANAGE_H#include \"type.h\"#include \"stm32f10x.h\"#define BATTERY_1_I2C_SCL_GPIO GPIOB#define BATTERY_1_I2C_SCL_PIN GPIO_Pin_8#define BATTERY_1_I2C_SDA_GPIO GPIOB#define BATTERY_1_I2C_SDA_PIN GPIO_Pin_9#define BATTERY_2_I2C_SCL_GPIO GPIOB#define BATTERY_2_I2C_SCL_PIN GPIO_Pin_10#define BATTERY_2_I2C_SDA_GPIO GPIOB#define BATTERY_2_I2C_SDA_PIN GPIO_Pin_11#define BQ34Z100_ADDR 0xAA#define SDA_1() do&#123;\\ GPIO_InitTypeDef GPIO_InitStructure;\\ GPIO_InitStructure.GPIO_Pin = BQ34Z100_SDA_pin;\\ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\\ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\\ GPIO_Init(BQ34Z100_GPIO_SDA, &amp;GPIO_InitStructure);\\ &#125; while (0)#define SDA_0() do&#123;\\ GPIO_InitTypeDef GPIO_InitStructure;\\ GPIO_InitStructure.GPIO_Pin = BQ34Z100_SDA_pin;\\ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\\ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;\\ GPIO_Init(BQ34Z100_GPIO_SDA, &amp;GPIO_InitStructure);\\ GPIO_ResetBits(BQ34Z100_GPIO_SDA, BQ34Z100_SDA_pin);\\ &#125; while (0)#define SCL_1() do&#123;\\ GPIO_InitTypeDef GPIO_InitStructure;\\ GPIO_InitStructure.GPIO_Pin = BQ34Z100_SCL_pin;\\ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\\ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\\ GPIO_Init(BQ34Z100_GPIO_SCL, &amp;GPIO_InitStructure);\\ &#125; while (0)#define SCL_0() do&#123;\\ GPIO_InitTypeDef GPIO_InitStructure;\\ GPIO_InitStructure.GPIO_Pin = BQ34Z100_SCL_pin;\\ GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\\ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;\\ GPIO_Init(BQ34Z100_GPIO_SCL, &amp;GPIO_InitStructure);\\ GPIO_ResetBits(BQ34Z100_GPIO_SCL, BQ34Z100_SCL_pin);\\ &#125; while (0)#define I2CDELAY() delay_nus(5)#define BQ34Z100_NACK 0#define BQ34Z100_ACK 1typedef struct &#123; u16 charge_state; u16 remain_cap; u16 full_charge_cap; u16 voltage; u16 temperature; u16 current; u16 flag;&#125; battery_t;#define BQ34Z100_CONTROL_LSB 0x00#define BQ34Z100_CONTROL_MSB 0x01#define BQ34Z100_STATE_OF_CHARGE 0x02#define BQ34Z100_MAX_ERROR 0x03#define BQ34Z100_REMAIN_CAP_LSB 0x04#define BQ34Z100_REMAIN_CAP_MSB 0x05#define BQ34Z100_FULL_CHAGRE_CAP_LSB 0x06#define BQ34Z100_FULL_CHAGRE_CAP_MSB 0x07#define BQ34Z100_VOLTAGE_LSB 0x08#define BQ34Z100_VOLTAGE_MSB 0x09#define BQ34Z100_AVA_CURRENT_LSB 0x0A#define BQ34Z100_AVA_CURRENT_MSB 0x0B#define BQ34Z100_TEMPERATURE_LSB 0x0C#define BQ34Z100_TEMPERATURE_MSB 0x0D#define BQ34Z100_FLAGS_LSB 0x0E#define BQ34Z100_FLAGS_MSB 0x0F#define BQ34Z100_CURRENT_LSB 0x10#define BQ34Z100_CURRENT_MSB 0x11#define BQ34Z100_FLAGSB_LSB 0x12#define BQ34Z100_FLAGSB_MSB 0x13#define LSB_BIT0 0x0001#define LSB_BIT1 0x0002#define LSB_BIT2 0x0004#define LSB_BIT3 0x0008#define LSB_BIT4 0x0010#define LSB_BIT5 0x0020#define LSB_BIT6 0x0040#define LSB_BIT7 0x0080#define MSB_BIT0 0x0100#define MSB_BIT1 0x0200#define MSB_BIT2 0x0400#define MSB_BIT3 0x0800#define MSB_BIT4 0x1000#define MSB_BIT5 0x2000#define MSB_BIT6 0x4000#define MSB_BIT7 0x8000#define FLAG_OTC MSB_BIT7 // 充电过温#define FLAG_OTD MSB_BIT6#define FLAG_BATHI MSB_BIT5#define FLAG_BATLOW MSB_BIT4#define FLAG_CHG_INH MSB_BIT3#define FLAG_XCHG MSB_BIT2#define FLAG_FC MSB_BIT1#define FLAG_CHG MSB_BIT0#define FLAG_OCVTAKEN LSB_BIT7#define FLAG_RSVD0 LSB_BIT6#define FLAG_RSVD1 LSB_BIT5#define FLAG_CF LSB_BIT4#define FLAG_RSVD2 LSB_BIT3#define FLAG_SOC1 LSB_BIT2#define FLAG_SOCF LSB_BIT1#define FLAG_DSG LSB_BIT0void BQ34Z100_get_charge_state(u8 battery_num);void battery_init(void);#endif","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM32/"}]},{"title":"2017,新的开始","slug":"2017flag","date":"2017-01-10T09:28:07.000Z","updated":"2017-01-10T01:55:31.630Z","comments":true,"path":"2017/01/10/2017flag/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2017/01/10/2017flag/","excerpt":"","text":"2017，给自己立下几个FLAG新语言 python3 C# C++ JAVA (OP) 新技能 嵌入式linux驱动开发 桌面应用 || 手机应用开发 新生活 再多学会做几个菜品 锻炼、锻炼、锻炼 新未来 结婚 买房 未完待续……","categories":[{"name":"2017","slug":"2017","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/2017/"}],"tags":[{"name":"2017","slug":"2017","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/2017/"}]},{"title":"STM32型号命名规则","slug":"STM32-NOTE","date":"2016-11-28T11:11:33.000Z","updated":"2016-12-09T02:36:57.880Z","comments":true,"path":"2016/11/28/STM32-NOTE/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/11/28/STM32-NOTE/","excerpt":"","text":"stm32型号命名规则示例： 12STM32 | F | 100 | C | 6 | T | 6 | B | XXX 1 2 3 4 5 6 7 8 9 从上面的料号可以看出以下信息： ST品牌ARM Cortex-Mx系列内核32位超值型MCU，LQFP -48封装 闪存容量32KB 温度范围-40℃-85℃； 产品系列:STM32代表ST品牌Cortex-Mx系列内核（ARM）的32位MCU； 产品类型: F：通用快闪（Flash Memory）；L：低电压（1.65～3.6V）；F类型中F0xx和 F1xx系列为2.0～3.6V; F2xx和F4xx系列为1.8～3.6V;W：无线系统芯片,开发版. 产品子系列：050：ARM Cortex-M0内核；051：ARM Cortex-M0内核；100：ARM Cortex-M3内核，超值型； 101：ARM Cortex-M3内核，基本型； 102：ARM Cortex-M3内核，USB基本型； 103：ARM Cortex-M3内核，增强型； 105：ARM Cortex-M3内核，USB互联网型； 107：ARM Cortex-M3内核，USB互联网型、以太网型； 108：ARM Cortex-M3内核，IEEE802.15.4标准； 151：ARM Cortex-M3内核，不带LCD； 152/162：ARM Cortex-M3内核，带LCD；205/207：ARM Cortex-M3内核，不加密模块.（备注：150DMIPS，高达1MB闪存/128+4KB RAM，USB OTG HS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头；）215/217：ARM Cortex-M3内核，加密模块。（备注：150DMIPS，高达1MB闪存/128+4KB RAM，USB OTG HS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头；）405/407：ARM Cortex-M4内核，不加密模块。（备注：MCU+FPU，210DMIPS，高达1MB闪存/192+4KB RAM，USB OTG HS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头）；415/417：ARM Cortex-M4内核，加密模块。（备注：MCU+FPU，210DMIPS，高达1MB闪存/192+4KB RAM，USB OTG HS/FS，以太网，17个TIM，3个ADC，15个通信外设接口和摄像头）； 管脚数:F：20PIN；G：28PIN；K：32PIN；T：36PIN；H：40PIN；C：48PIN；U：63PIN；R：64PIN；O：90PIN；V：100PINQ：132PIN；Z：144PIN； I：176PIN； Flash存存容量:4：16KB flash；（小容量）; 6：32KB flash；（小容量）;8：64KB flash；（中容量）;B：128KB flash；（中容量）;C：256KB flash；（大容量）;D：384KB flash；（大容量）;E：512KB flash；（大容量）;F：768KB flash；（大容量）;G：1MKB flash；（大容量） 封装:T：LQFP；H：BGA；U：VFQFPN；Y：WLCSP/ WLCSP64； 温度范围:6：-40℃-85℃；（工业级）; 7：-40℃-105℃；（工业级） 内部代码:“A” or blank; A：48/32脚封装；Blank：28/20脚封装; 包装方式：TR：带卷； XXX：盘装;D：电压范围1.65V – 3.6V且BOR无使能；无特性：电压范围1.8V – 3.6V且BOR使能；","categories":[],"tags":[]},{"title":"ARM寻址方式","slug":"ARM-Addressing-Mode","date":"2016-10-12T09:20:43.000Z","updated":"2016-10-12T06:09:07.396Z","comments":true,"path":"2016/10/12/ARM-Addressing-Mode/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/10/12/ARM-Addressing-Mode/","excerpt":"","text":"ARM 处理器寻址方式所谓寻址方式，是根据指令中的地址码来实现寻找真实操作数地址的方式，ARM处理器有9种基本寻址方式。 寄存器寻址操作数的值在寄存器中，指令中的地址码指出的是寄存器编号，指令执行时直接取出寄存器值操作。 立即寻址立即寻址指令中的操作码字段后面的地址码部分就是操作数本身，也就是说，数据就包含在指令当中，取出指令也就取出了可以立即使用的操作数（立即数）。 12SUBS R0,R0,#1MOV R0,#0xFF00 立即数要以“#”为前缀。 寄存器偏移寻址寄存器偏移寻址是ARM指令集特有的寻址方式，当第2操作数是寄存器偏移方式时，第2个寄存器操作数在与第1个操作数结合之前，进行移位操作。 12MOV R0,R2,LSL #3 ;R2的值左移3位，结果放入R0ANDS R1,R1,R2,LSL R3 ;R2的值左移R3位，然后与R1相与，结果放入R1 可采用的移位操作如下： LSL: 逻辑左移（Logical Shift Left）,寄存器中字的底端空出的位补0 LSR: 逻辑右移（Logical Shift Right）,寄存器的高端空出位补0 ASR: 算术右移（Arithmetic Shift Right）,移位过程中保持符号位不变，即如果源操作数为正数，则字的高端空出的位补0，否则补1 ROR: 循环右移(Rotate Right),由字的低端移出的位填入字的高端空出的位 RRX:带拓展标志的循环右移(Rotate Right Extended By 1place),操作数右移一位，高端空出的位用原C标志值填充 寄存器间接寻址寄存器间接寻址指令中的地址码给出的是一个通用的寄存器编号，所需要的操作数保存在寄存器指定地址的存储单元中，即寄存器为操作数的地址指针 12LDR R1,[R2] ;将R2中的数值作为地址，取出此地址中的数据保存在R1中SWP R1,R1,[R2] ;将R2中的数值作为地址，取出此地址中的数值与R1中的值交换 基址寻址基址寻址是将基址寄存器的内容与指令中给出的偏移量相加，形成操作数的有效地址，基址寻址用于访问基址附近的存储单元，常用于查表，数组操作，功能部件寄存器访问等。 12LDR R2,[R3,#0x0F] STR R1,[R0,#-2] 多寄存器寻址多寄存器寻址就是一次可以传送几个寄存器的值，允许一条指令传送16个寄存器的任何子集或者所有寄存器。 12LDMIA R1!,&#123;R2-R7,R12&#125; ;将R1单元中的数据读出到R2-R7,R12,R1自动加1STMIA R0!,&#123;R3-R6,R10&#125; ;将R3-R6,R10中的数据保存到R0指向的地址，R0自动加1 使用多寄存器寻址指令时，寄存器子集的顺序由小到大的顺序排列，连续的寄存器可用“-”连接，否则，用“,”分割书写。 堆栈寻址堆栈是按照特定顺序进行存取的存储区，操作顺序分为“后进先出”和“先进后出”，堆栈寻址时隐含的，它使用一个专门的寄存器（堆栈指针）指向一块存储区域（堆栈），指针所指向的存储单元就是堆栈的栈顶。存储器堆栈可分为两种： 向上生长: 向高地址方向生长，称为递增堆栈 向下生长: 向低地址方向生长，称为递减堆栈 堆栈指针指向最后压入的有效数据项，称为满堆栈；堆栈指针指向下一个要放入的空位置，称为空堆栈。这样就有四种类型的堆栈表示递增和递减的满堆栈和空堆栈的各种组合。 满递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向含有有效数据项的最高地址。指令如LDMFA、STMFA等。 空递增：堆栈通过增大存储器的地址向上增长，堆栈指针指向堆栈上的第一个空位置。指令如LDMEA,STMEA等。 满递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向内含有有效数据的最低地址。指令如LDMFD，STMFD等。 空递减：堆栈通过减小存储器的地址向下增长，堆栈指针指向堆栈下的第一个空位置。指令如LDMED，STMED等。 12STMFD SP!,&#123;R1-R7,LR&#125; ;将R1-R7,LR入栈。满递减堆栈LDMFD SP!,&#123;R1-R7,LR&#125; ;数据出栈，满递减堆栈 块拷贝寻址多寄存器传送指令用于一块数据从存储器的某一位置拷贝到另一位置。 1STMIA R0!,&#123;R1-R7&#125; ;将R1-R7的数据保存到存储器中，存储器指针在保存第一个值后增加，增长方向为向上增长。 相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到的地址即为操作数的有效地址。","categories":[],"tags":[{"name":"ARM","slug":"ARM","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/ARM/"}]},{"title":"开始嵌入式linux学习","slug":"startEmbeded","date":"2016-09-23T09:05:55.000Z","updated":"2016-09-29T07:59:38.549Z","comments":true,"path":"2016/09/23/startEmbeded/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/09/23/startEmbeded/","excerpt":"","text":"从事单片机开发算起来也有快三年了，从慢慢摸索起步，到正儿八经的做项目，接国家课题，在单片机上花了很多功夫。期间做过简单的智能排气扇，也做过高大上的从下位机到上位机全部自己包办的国家级项目“楼宇安防系统”，单片机也从51到430再到ARM，我想我应该算是一合格的单片机开发者了吧。 一直是裸机开发，对操作系统那块一直没有深入学习，只研究过freeRTOS这个实时系统，而且还没有用在实际开发中。最近很想玩玩操作系统，而且我希望以后进入物联网行业，对于物联网来说，我觉得跑系统是在是太有必要了，所以，打算从今儿开始，花一个月(应该不短吧)学习嵌入式linux，从裸机开发过渡到操作系统下的嵌入式开发上。 一个月以后，回头再看今天写下的话，希望我已经是个可以从事嵌入式linux开发的程序猿了^_^","categories":[],"tags":[]},{"title":"可以间接消抖的按键长按短按识别","slug":"keyLongOrShort","date":"2016-09-18T16:29:07.000Z","updated":"2016-09-18T09:09:57.758Z","comments":true,"path":"2016/09/19/keyLongOrShort/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/09/19/keyLongOrShort/","excerpt":"","text":"按键按下时触发按键计时，按键释放结束计时，计时时间Tkey &lt; Tshort 时，判为短按。Tkey &gt; Tlong时，判为长按。按键在触发时需要消除抖动，抖动本质上也是一次极短的短按，因此可以根据短按时间来消除抖动。定时器定时扫描端口，源代码如下： 123456789101112131415161718192021222324252627282930if (D_keyDown()) &#123; if (x_key.keyTmCnt &lt; D_maxCntNum) &#123; x_key.keyTmCnt++; &#125; if (x_key.keyTmCnt &gt;= D_timeShortKey) /* 大于D_minTimeFilter判为有效按键,短按 */ &#123; x_key.shortKeyFlag = D_TRUE; &#125; if (x_key.keyTmCnt &gt;= D_timeLongKey) /* 长按 */ &#123; x_key.keyState = D_keyPushLong; if (x_key.shortKeyFlag == D_TRUE) &#123; x_key.shortKeyFlag = D_FALSE; /* 清楚短按标志，防止误触发，很重要 */ &#125; &#125;&#125;else&#123; x_key.keyTmCnt = 0; if (x_key.shortKeyFlag == D_TRUE) &#123; x_key.shortKeyFlag = D_FALSE; x_key.keyState = D_keyPushShort; &#125;&#125;","categories":[{"name":"单片机","slug":"单片机","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/单片机/"}],"tags":[{"name":"按键识别","slug":"按键识别","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/按键识别/"}]},{"title":"freeRTOS中文文档","slug":"freeRTOS-CN","date":"2016-08-29T14:36:05.000Z","updated":"2017-04-06T00:48:19.000Z","comments":true,"path":"2016/08/29/freeRTOS-CN/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/29/freeRTOS-CN/","excerpt":"","text":"freeRTOS中文文档 V0.0.1 文档由来因为最近在学习freeRTOS，官方没有中文站点，另外由于服务器原因，freeRTOS.net这个中文站点已经很久没法访问了。因此索性边学边翻译，方便自己学习的同时，为国内的小伙伴们做些点点贡献。因水平有限，其中难免会出现翻译不准确的地方，欢迎斧正。 文档地址freeRTOS中文文档 进度记录 2016.09.09 进阶部分完成 2016.08.29 软件定时器，完成入门部分 2016.08.28 通信机制和事件组 2016.08.26 任务与协程 2016.08.25 freeRTOS简介 2016.08.25 创建 项目托管GitHub 个人博客 不足之处因为原版英文中有很多专业性的描述，并且这个翻译也是在一边学一边记录的过程下产生的，有些理解的不透彻的地方，我会直接贴出英文原文，方便后期再仔细斟酌如何翻译，即使如此，文中仍然可能(甚至是肯定的)会出现一些片面的、不准确的翻译。因此，这个中文文档只能作为一个参考，英文能力好的，还是推荐阅读英文原版。 进度安排因为还在工作，无法保证进度，不定时更新。见谅。可关注我的个人博客，除了托管在gitHub上，博客上也会有一份备份。 参考资料 freeRTOS官网 license再次声明，虽然很多地方增加了自己的理解和为了方便理解使用更加形象的描述，但是所有内容仍然非原创，全部从官方英文站点翻译整理而来，而此翻译文档遵循以下协议： 本作品采用知识共享署名 4.0 国际许可协议进行许可。","categories":[],"tags":[{"name":"freeRTOS 中文文档","slug":"freeRTOS-中文文档","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/freeRTOS-中文文档/"}]},{"title":"CSharp 定义类成员关键字","slug":"CSharpKeyWords","date":"2016-08-22T14:36:05.000Z","updated":"2016-08-29T02:07:31.704Z","comments":true,"path":"2016/08/22/CSharpKeyWords/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/22/CSharpKeyWords/","excerpt":"","text":"定义字段：public成员可以由任何代码访问。private成员只能由类中的代码访问（默认）。internal成员只能由定义它的程序集（内部）的代码访问 。protected成员只能由类货派生类中的代码访问。internal protected可以一起使用，表示仅能由项目中的派生类访问static 用在类里的属性、方法前面: 这样的静态属性与方法不需要创建实例就能访问，通过类名或对象名都能访问它，静态属性、方法只有“一份”：即如果一个类新建有N个对象，这N 个对象只有同一个静态属性与方法；可以用来作为全局变量在不同窗口间完成数据共享 方法内部的静态变量：方法内部的静态变量，执行完静态变量值不消失，再次执行此对象的方法时，值仍存在，它不是在栈中分配的，是在静态区分析的， 这是与局部变量最大的区别； 定义方法：virtual方法可以重写abstract方法必须在非抽象的派生类中重写（只用于抽象类中）override方法重写了一个基类方法（基类方法必须是可重写的方法，如果重写方法，就必须使用该关键字）extern方法定义放在其他地方sealed封闭，不允许派生类重写 定义属性：与定义字段类似，但是需要定义访问器，通过get set关键字定义","categories":[],"tags":[]},{"title":"TTL电平,CMOS电平,OC门,OD门基础知识","slug":"TTL-CMOS","date":"2016-08-08T18:10:05.000Z","updated":"2016-08-08T10:38:43.747Z","comments":true,"path":"2016/08/09/TTL-CMOS/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/09/TTL-CMOS/","excerpt":"","text":"转载: TTL电平,CMOS电平,OC门,OD门基础知识 TTLTTL集成电路的主要型式为晶体管－晶体管逻辑门（transistor-transistor logic gate），TTL大部分都采用5V电源。 输出高电平Uoh和输出低电平Uol Uoh≥2.4V,Uol≤0.4V 输入高电平和输入低电平 Uih≥2.0V，Uil≤0.8V CMOSCMOS电路是电压控制器件，输入电阻极大，对于干扰信号十分敏感，因此不用的输入端不应开路，接到地或者电源上。CMOS电路的优点是噪声容限较宽，静态功耗很小。 输出高电平Uoh和输出低电平Uol Uoh≈VCC，Uol≈GND 输入高电平Uoh和输入低电平Uol Uih≥0.7VCC,Uil≤0.2VCC （VCC为电源电压，GND为地） 从上面可以看出:在同样5V电源电压情况下，COMS电路可以直接驱动TTL，因为CMOS的输出高电平大于2.0V,输出低电平小于0.8V；而TTL电路则不能直接 驱动CMOS电路，TTL的输出高电平为大于2.4V，如果落在2.4V～3.5V之间，则CMOS电路就不能检测到高电平，低电平小于0.4V满足要 求，所以在TTL电路驱动COMS电路时需要加上拉电阻。如果出现不同电压电源的情况，也可以通过上面的方法进行判断。如果电路中出现3.3V的COMS电路去驱动5V CMOS电路的情况，如3.3V单片机去驱动74HC,这种情况有以下几种方法解决，最简单的就是直接将74HC换成74HCT（74系列的输入输出在下 面有介绍）的芯片，因为3.3V CMOS 可以直接驱动5V的TTL电路；或者加电压转换芯片；还有就是把单片机的I/O口设为开漏，然后加上拉电阻到5V，这种情况下得根据实际情况调整电阻的大 小，以保证信号的上升沿时间。 74系列简介74系列可以说是我们平时接触的最多的芯片，74系列中分为很多种，而我们平时用得最多的应该是以下几种：74LS，74HC，74HCT这三种，这三种系列在电平方面的区别如下： 型号 输入电平 输出电平 74LS TTL电平 TTL电平 74HC COMS电平 COMS电平 74HCT TTL电平 COMS电平 TTL和CMOS电平TTL电平(什么是TTL电平)输出高电平&gt;2.4V,输出低电平=2.0V，输入低电平&lt;=0.8V，噪声容限是0.4V。 CMOS电平“1”逻辑电平电压接近于电源电压，”0”逻辑电平接近于0V。而且具有很宽的噪声容限。 电平转换电路因为TTL和COMS的高低电平的值不一样（ttl 5v&lt;＝＝&gt;cmos 3.3v），所以互相连接时需要电平的转换：就是用两个电阻对电平分压，没有什么高深的东西。 OC门即集电极开路门电路，OD门，即漏极开路门电路，必须外界上拉电阻和电源才能将开关电平作为高低电平用。否则它一般只作为开关大电压和大电流负载，所以又叫做驱动门电路。 TTL和COMS电路比较 TTL电路是电流控制器件，而CMOS电路是电压控制器件。 TTL电路的速度快，传输延迟时间短(5-10ns)，但是功耗大。COMS电路的速度慢，传输延迟时间长(25-50ns),但功耗低。COMS电路本身的功耗与输入信号的脉冲频率有关，频率越高，芯片集越热，这是正常现象。 COMS电路的锁定效应： COMS电路由于输入太大的电流，内部的电流急剧增大，除非切断电源，电流一直在增大。这种效应就是锁定效应。当产生锁定效应时，COMS的内部电流能达到40mA以上，很容易烧毁芯片。 防御措施： 在输入端和输出端加钳位电路，使输入和输出不超过不超过规定电压。 芯片的电源输入端加去耦电路，防止VDD端出现瞬间的高压。 在VDD和外电源之间加限流电阻，即使有大的电流也不让它进去。 当系统由几个电源分别供电时，开关要按下列顺序：开启时，先开启COMS路得电 源，再开启输入信号和负载的电源；关闭时，先关闭输入信号和负载的电源，再关闭COMS电路的电源。 COMS电路的使用注意事项 COMS电路时电压控制器件，它的输入总抗很大，对干扰信号的捕捉能力很强。所以，不用的管脚不要悬空，要接上拉电阻或者下拉电阻，给它一个恒定的电平。 输入端接低内阻的信号源时，要在输入端和信号源之间要串联限流电阻，使输入的电流限制在1mA之内。 当接长信号传输线时，在COMS电路端接匹配电阻。 当输入端接大电容时，应该在输入端和电容间接保护电阻。电阻值为R=V0/1mA.V0是外界电容上的电压。 COMS的输入电流超过1mA，就有可能烧坏COMS。 TTL门电路中输入端负载特性(输入端带电阻特殊情况的处理) 悬空时相当于输入端接高电平。因为这时可以看作是输入端接一个无穷大的电阻。 在门电路输入端串联10K电阻后再输入低电平，输入端出呈现的是高电平而不是低电平。因为由TTL门电路的输入端负载特性可知，只有在输入端接的串联电阻小于910欧时，它输入来的低电平信号才能被门电路识别出来，串联电阻再大的话输入端就一直呈现高电平。这个一定要注意。COMS门电路就不用考虑这些了。 TTL电路有集电极开路OC门，MOS管也有和集电极对应的漏极开路的OD门，它的输出就叫做开漏输出。OC门在截止时有漏电流输出，那就是漏电流，为什么有漏电流呢？那是因为当三极管截止的时候，它的基极电流约等于0，但是并不是真正的为0，经过三极管的集电极的电流也就不是真正的 0，而是约0。而这个就是漏电流。 开漏输出：OC门的输出就是开漏输出；OD门的输出也是开漏输出。它可以吸收很大的电流，但是不能向外输出的电流。所以，为了能输入和输出电流，它使用的时候要跟电源和上拉电阻一齐用。OD门一般作为输出缓冲/驱动器、电平转换器以及满足吸收大负载电流的需要。 什么叫做图腾柱，它与开漏电路有什么区别TTL集成电路中，输出有接上拉三极管的输出叫做图腾柱输出，没有的叫做OC门。因为TTL就是一个三级关，图腾柱也就是两个三级管推挽相连。所以推挽就是图腾。一般图腾式输出，高电平400UA，低电平8MACMOS 器件不用的输入端必须连到高电平或低电平, 这是因为 CMOS 是高输入阻抗器件, 理想状态是没有输入电流的. 如果不用的输入引脚悬空, 很容易感应到干扰信号, 影响芯片的逻辑运行, 甚至静电积累永久性的击穿这个输入端, 造成芯片失效.另外, 只有 4000 系列的 CMOS 器件可以工作在15伏电源下, 74HC, 74HCT 等都只能工作在 5伏电源下, 现在已经有工作在 3伏和 2.5伏电源下的 CMOS 逻辑电路芯片了. CMOS逻辑电平范围比较大，范围在3～15V，比如4000系列当5V供电时，输出在4.6以上为高电平，输出在0.05V以下为低电平。输入在3.5V以上为高电平，输入在1.5V以下为低电平。而对于TTL芯片，供电范围在0～5V，常见都是5V，如74系列5V供电，输出在2.7V以上为高电平，输出在 0.5V以下为低电平，输入在2V以上为高电平，在0.8V以下为低电平。因此，CMOS电路与 TTL电路就有一个电平转换的问题，使两者电平域值能匹配。有关逻辑电平的一些概念 ：要了解逻辑电平的内容，首先要知道以下几个概念的含义： 输入高电平（Vih）：保证逻辑门的输入为高电平时所允许的最小输入高电平，当输入电平高于Vih时，则认为输入电平为高电平。输入低电平（Vil）：保证逻辑门的输入为低电平时所允许的最大输入低电平，当输入电平低于Vil时，则认为输入电平为低电平。输出高电平（Voh）：保证逻辑门的输出为高电平时的输出电平的最小值，逻辑门的输出为高电平时的电平值都必须大于此Voh。输出低电平（Vol）：保证逻辑门的输出为低电平时的输出电平的最大值，逻辑门的输出为低电平时的电平值都必须小于此Vol。阀值电平(Vt)：数字电路芯片都存在一个阈值电平，就是电路刚刚勉强能翻转动作时的电平。它是一个界于Vil、Vih之间的电压值，对于CMOS电路 的阈值电平，基本上是二分之一的电源电压值，但要保证稳定的输 出，则必须要求输入高电平&gt; Vih，输入低电平 Vih &gt; Vt &gt; Vil &gt; Vol Ioh：逻辑门输出为高电平时的负载电流（为拉电流）。 Iol：逻辑门输出为低电平时的负载电流（为灌电流）。 Iih：逻辑门输入为高电平时的电流（为灌电流）。 Iil：逻辑门输入为低电平时的电流（为拉电流）。 门电路输出极在集成单元内不接负载电阻而直接引出作为输出端，这种形式的门称为开路门。开路的TTL、CMOS、ECL门分别称为集电极开路（OC）、 漏极开路（OD）、发射极开路（OE），使用时应审查是否接上拉电阻（OC、OD门）或下拉电阻（OE门），以及电阻阻值是否合适。对于集电极开路 （OC）门，其上拉电阻阻值RL应满足下面条件： - RL &lt; （VCC－Voh）/（n*Ioh＋m*Iih） - RL &gt; （VCC－Vol）/（Iol＋m*Iil） 其中n：线与的开路门数；m：被驱动的输入端数。 常用的逻辑电平逻辑电平：有TTL、CMOS、LVTTL、ECL、PECL、GTL；RS232、RS422、LVDS等。其中TTL和CMOS的逻辑电平按典型电压可分为四类：5V系列（5V TTL和5V CMOS）、3.3V系列，2.5V系列和1.8V系列。5V TTL和5V CMOS逻辑电平是通用的逻辑电平。3.3V及以下的逻辑电平被称为低电压逻辑电平，常用的为LVTTL电平。低电压的逻辑电平还有2.5V和1.8V两种。ECL/PECL和LVDS是差分输入输出。RS-422/485和RS-232是串口的接口标准，RS-422/485是差分输入输出，RS-232是单端输入输出。OC门，又称集电极开路（漏极开路）与非门门电路，Open Collector（Open Drain）。 为什么引入OC门实际使用中,有时需要两个或两个以上与非门的输出端连接在同一条导线上，将这些与非门上的数据（状态电平）用同一条导线输送出去。因此，需要一种新的与非门电路–OC门来实现“线与逻辑”。OC门主要用于3个方面:实现与或非逻辑，用做电平转换，用做驱动器。由于OC门电路的输出管的集电极悬空，使用时需外接一个上拉电阻Rp到电源VCC。OC门使用上拉电阻以输出高电平，此外为了加大输出引脚的驱动能力，上拉电阻阻值的选择原则，从降低功耗及芯片的灌电流能力考虑应当足够大；从确保足够的驱动电流考虑应当足够小。线与逻辑，即两个输出端（包括两个以上）直接互连就可以实现“AND”的逻辑功能。在总线传输等实际应用中需要多个门的输出端并联连接使用，而一般 TTL门输出端并不能直接并接使用，否则这些门的输出管之间由于低阻抗形成很大的短路电流（灌电流），而烧坏器件。在硬件上，可用OC门或三态门（ST 门）来实现。用OC门实现线与，应同时在输出端口应加一个上拉电阻。三态门（ST门）主要用在应用于多个门输出共享数据总线，为避免多个门输出同时占用数据总线，这些门的使能信号（EN）中只允许有一个为有效电平（如高电平），由于三态门的输出是推拉式的低阻输出，且不需接上拉（负载）电阻，所以开关速度比OC门快，常用三态门作为输出缓冲器 什么是OC、OD？集电极开路门(集电极开路 OC 或漏极开路 OD)Open-Drain是漏极开路输出的意思，相当于集电极开路(Open-Collector)输出，即TTL中的集电极开路（OC）输出。一般用于线或、线与，也有的用于电流驱动。Open-Drain是对MOS管而言，Open-Collector是对双极型管而言，在用法上没啥区别。 开漏形式的电路有以下几个特点： 利用外部电路的驱动能力，减少IC内部的驱动。 或驱动比芯片电源电压高的负载. 可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线 判断总线占用状态的原理。如果作为图腾输出必须接上拉电阻。接容性负载时，下降延是芯片内的晶体管，是有源驱动，速度较快；上升延是无源的外接电阻，速度慢。如果要求速度高电阻选择要小，功耗会大。所以负载电阻的选择要兼顾功耗和速度。 可以利用改变上拉电源的电压，改变传输电平。例如加上上拉电阻就可以提供TTL/CMOS电平输出等。 开漏Pin不连接外部的上拉电阻，则只能输出低电平。一般来说，开漏是用来连接不同电平的器件，匹配电平用的。 正常的CMOS输出级是上、下两个管子，把上面的管子去掉就是OPEN-DRAIN了。这种输出的主要目的有两个：电平转换和线与。由于漏级开路，所以后级电路必须接一上拉电阻，上拉电阻的电源电压就可以决定输出电平。这样你就可以进行任意电平的转换了。线与功能主要用于有多个电路对同一信号进行拉低操作的场合，如果本电路不想拉低，就输出高电平，因为OPEN-DRAIN上面的管子被拿掉，高电平是靠外接的上拉电阻实现的。（而正常的CMOS输出级，如果出现一个输出为高另外一个为低时，等于电源短路。）OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。","categories":[{"name":"others","slug":"others","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/others/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/数字电路/"}]},{"title":"IIC","slug":"IIC","date":"2016-08-08T16:41:15.000Z","updated":"2016-09-14T02:45:02.031Z","comments":true,"path":"2016/08/09/IIC/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/09/IIC/","excerpt":"","text":"I2C总线是一个多主(从)机、单端、串行通信总线，由飞利浦公司(现在的NXP公司)发明。典型应用是那些短距、低速的应用场合。使用I2C是不需要许可费的，但是如果使用NXP提供的地址字段，则需要支付相关费用。 总线结构I2C是双向开漏两线制总线，由电阻上拉。SDA是其串行数据线，SCL是总线时钟线，用以提供时钟基准。I2C地址空间有7bit和10bit两种，大多数I2C提供100kbit/s的通信速率，当然这些都不是标准的一部分，视具体应用而定。鉴于通信帧中包含从机地址、从机应答等信息，实际的数据通信速率会比标称的峰值速率低。 最大的从机数目由地址空间的位数决定，同时总线上的电容大小总和受到400PF的限制，这限制了实际的通信距离只有几米，同时为了保证高阻抗和低噪声，一个共同的地也是潜在的需求，这会限制线路板的设计。 物理层在物理层上，SCL与SDA都是开漏设计，因此需要一个上拉电阻，将总线拉低来设置逻辑”0”,悬浮时总线被设置成逻辑”1”,是一个线与逻辑，总线上的任何一个设备拉低总线都会导致总线为低，因此当总线为低时，必定有其他设备在使用总线，此时总线为BUSY状态，因此设备可以依靠SDA避免总线冲突。 当总线空闲时，两条线都是高状态，启动一次传输，可以通过拉低SDA而保持SCL为高发出START信号，释放SDA而保持SCL为高将产生STOP信号。除了START与STOP信号，SDA需保持其状态在SCL为低时，仅当SCL为高时允许切换SDA状态。当SCL为低时，由发送器将SDA状态切换至下一状态，然后主机将SCL设置成高电平，一旦SCL为高，接收器读取SDA状态。 总线协议(以24Cxx系列EEPROM为例)I2C总线的一个典型应用即是EEPROM。24Cxx系列存储芯片的操作主要有读写两类(有些芯片还有擦除操作，因为比较特殊，同时写操作同样可以达到同样目的，在此按下不表)。读写操作使用同样的通信协议:先写从机地址，接着传输数据直到结束信号到来。 写操作首先主机发送开始信号START唤醒总线上的从机，接着发送从机地址(包含写信息)，从机在接收到之后与自己的地址信息进行比较，如果匹配则准备接收数据，否则忽略数据。接着发送需要写入的数据地址及数据，最后发送停止信号。从机在此期间将执行自己的状态机完成数据的接收与写入。(需要注意的是24Cxx系列的EEPROM没法跨页写，也就是对于跨页写入的数据需要执行两次写周期)写入期间，从机一只处在BUSY状态，对外界一切信息均不作响应，写入完成后从机响应ACK信号。 读操作与写操作类似，首先主机发送开始信号START唤醒总线上的从机，接着发送从机地址(包含写信息)，从机在接收到之后与自己的地址信息进行比较，如果匹配则准备接收数据，否则忽略数据。然后再次发送START信号与从机地址(包含读信息)，从机在收到后返回相应数据，主机在收到数据后发送应带ACK或者NCK通知从机接着接收完成或发送下一字节数据，从机发送完最后一个字节数据后，主机可不响应应答信号。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290//函数声明void Delay_EEPROM(void);void EEPROM_I2C_Init(void);void EEPROM_I2C_Start(void);void EEPROM_I2C_Stop(void);unsigned char EEPROM_ReceiveByte( unsigned char ACK );unsigned char EEPROM_SendByte( unsigned char Data );unsigned char I2C_Read( unsigned char* RAM_Addr, unsigned int EEPROM_Addr, unsigned char Lenth );unsigned char I2C_Write( unsigned int EEPROM_Addr, unsigned char* RAM_Addr, unsigned char Lenth );/***********************************************************************//* 函数名称：Delay_EEPROM *//* 函数功能：延时子程序 *//***********************************************************************/void Delay_EEPROM(void)&#123; _NOP();_NOP(); _NOP();_NOP();&#125;/***********************************************************************//* 函数名称：EEPROM_I2C_Init *//* 函数功能：I2C管脚初始化 *//***********************************************************************/void EEPROM_I2C_Init(void)&#123; IO_EEPROM_SCL_OUT_H; IO_EEPROM_SDA_OUT_H; IO_EEPROM_SCL_DIR_OUT; IO_EEPROM_SDA_DIR_OUT;&#125;/***********************************************************************//* 函数名称：EEPROM_I2C_Start *//* 函数功能：启动I2C总线 *//* 描述：SCL为高电平时，SDA发出下降沿信号 *//***********************************************************************/void EEPROM_I2C_Start(void)&#123; IO_EEPROM_SDA_OUT_H; //SDA=1 Delay_EEPROM(); IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); IO_EEPROM_SDA_OUT_L; //SDA=0 Delay_EEPROM(); IO_EEPROM_SCL_OUT_L; //SCL=0 Delay_EEPROM();&#125;/***********************************************************************//* 函数名称：EEPROM_I2C_Stop *//* 函数功能：停止I2C总线 *//* 描述：SCL为高电平时，SDA发出上升沿信号 *//***********************************************************************/void EEPROM_I2C_Stop(void)&#123; IO_EEPROM_SDA_OUT_L; //SDA=0 Delay_EEPROM(); IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); IO_EEPROM_SDA_OUT_H; //SDA=1 Delay_EEPROM(); IO_EEPROM_SDA_DIR_OUT; IO_EEPROM_SCL_DIR_OUT; IO_EEPROM_SDA_OUT_H; IO_EEPROM_SCL_OUT_H;&#125;/***********************************************************************//* 函数名称：EEPROM_ReceiveByte *//* 函数功能：接收一个字节数据，并发送应答信号 *//* 描述：在SCL高电平时，读取SDA信号 *//* 输入参数：ACK：应答信号 *//* 输出参数：读取数据 *//***********************************************************************/unsigned char EEPROM_ReceiveByte( unsigned char ACK )&#123; unsigned char i,Data=0x00; IO_EEPROM_SDA_DIR_IN; //SDA输入 for( i=0;i&lt;8;i++ ) &#123; IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); Data = Data&lt;&lt;1; if( IO_EEPROM_SDA_IN) &#123; Data |= 0x01; &#125; IO_EEPROM_SCL_OUT_L; //SCL=0 Delay_EEPROM(); &#125; //发送应答位 IO_EEPROM_SDA_DIR_OUT; //SDA输出 if( ACK == 1 ) &#123; IO_EEPROM_SDA_OUT_H; //SDA=1 &#125; else &#123; IO_EEPROM_SDA_OUT_L; //SDA=0 &#125; IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); IO_EEPROM_SCL_OUT_L; //SCL=0 return Data;&#125;/***********************************************************************//* 函数名称：EEPROM_SendByte *//* 函数功能：发送一个字节数据或地址，并判断应答信号 *//* 描述：在SCL下降沿时，发送SDA信号 *//* 输入参数：Data：待发送的信息 *//* 输出参数：0为成功，1为失败 *//***********************************************************************/unsigned char EEPROM_SendByte( unsigned char Data )&#123; unsigned char i,ACK; for( i=0;i&lt;8;i++ ) &#123; if( Data &amp; 0x80 ) &#123; IO_EEPROM_SDA_DIR_IN; &#125; else &#123; IO_EEPROM_SDA_DIR_OUT; IO_EEPROM_SDA_OUT_L; &#125; IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); Delay_EEPROM(); IO_EEPROM_SCL_OUT_L; //SCL=0 Data=Data&lt;&lt;1; &#125; //应答位检查 IO_EEPROM_SDA_DIR_IN; //SDA输入 Delay_EEPROM(); IO_EEPROM_SCL_OUT_H; //SCL=1 Delay_EEPROM(); ACK = IO_EEPROM_SDA_IN; //正常情况ACK信号应该为0 IO_EEPROM_SCL_OUT_L; //SCL=0 IO_EEPROM_SDA_DIR_OUT; //SDA输出 Delay_EEPROM(); return ACK;&#125;/***********************************************************************//* 函数名称：_E2Pread *//* 函数功能：从EEPROM里读数据 *//* 输入参数：RAM_Addr：目的地址 *//* EEPROM_Addr：源地址 *//* Lenth：数据长度 *//* 输出参数：0为成功，其余为失败 *//***********************************************************************/unsigned char I2C_Read( unsigned char* RAM_Addr, unsigned int EEPROM_Addr, unsigned char Lenth )&#123; unsigned char ChipAddr,Addr,ACK,i=0; ClrWdt(); EEPROM_I2C_Init(); EEPROM_I2C_Start(); //ChipAddr = 0xAE; ChipAddr = (EEPROM_ICAddr | ((EEPROM_Addr&gt;&gt;13)&amp;0x06)); while( i &lt; 200 )//判断EEPROM能否正常操作 &#123; if( EEPROM_SendByte(ChipAddr) == 0 )//发送器件地址 &#123; break; &#125; EEPROM_I2C_Stop(); EEPROM_I2C_Start(); i++; &#125; if( i &gt;= 200 ) &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; else Flag.Error &amp;= ~F_EEPROM_Err; Addr = ((unsigned char)(EEPROM_Addr&gt;&gt;8) &amp; 0x3F); if( EEPROM_SendByte(Addr) )//发送子地址高位 &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; Addr = (unsigned char)EEPROM_Addr; if( EEPROM_SendByte(Addr) )//发送子地址低位 &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; EEPROM_I2C_Start(); ChipAddr |= 0x01; if( EEPROM_SendByte(ChipAddr) )//发送器件地址，读命令 &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; while( (Lenth--) &gt; 0 ) &#123; if( Lenth != 0 ) ACK = 0; else ACK = 1; *RAM_Addr = EEPROM_ReceiveByte(ACK); RAM_Addr++; &#125; EEPROM_I2C_Stop(); return 0;&#125;/***********************************************************************//* 函数名称：_E2Pwrite *//* 函数功能：往EEPROM里写数据 *//* 输入参数：EEPROM_Addr：目的地址 *//* RAM_Addr：源地址 *//* Lenth：数据长度 *//* 输出参数：0为成功，其余为失败 *//***********************************************************************/unsigned char I2C_Write( unsigned int EEPROM_Addr, unsigned char* RAM_Addr, unsigned char Lenth )&#123; unsigned char ChipAddr,Addr,i=0; ClrWdt(); EEPROM_I2C_Init(); EEPROM_I2C_Start(); //ChipAddr = 0xAE; ChipAddr = (EEPROM_ICAddr | ((EEPROM_Addr&gt;&gt;13)&amp;0x06)); //EEPROM在完成一次写入命令后要延迟5到10毫秒，通过连续发器件地址，一旦总线正常，即立刻进行下一次总线操作 while( i &lt; 200 )//判断EEPROM能否正常操作 &#123; if( EEPROM_SendByte(ChipAddr) == 0 )//发送器件地址 &#123; break; &#125; EEPROM_I2C_Stop(); EEPROM_I2C_Start(); i++; &#125; if( i &gt;= 200 ) &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; else Flag.Error &amp;= ~F_EEPROM_Err; Addr = ((unsigned char)(EEPROM_Addr&gt;&gt;8) &amp; 0x3F); if( EEPROM_SendByte(Addr) )//发送子地址高位 &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; Addr = (unsigned char)EEPROM_Addr; if( EEPROM_SendByte(Addr) )//发送子地址低位 &#123; EEPROM_I2C_Stop(); Flag.Error |= F_EEPROM_Err;//器件不正常 return 0xFF; &#125; do &#123; EEPROM_SendByte(*RAM_Addr); RAM_Addr++; &#125; while( (--Lenth) &gt; 0 ); EEPROM_I2C_Stop(); return 0;&#125;","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/总线协议/"}],"tags":[{"name":"总线协议","slug":"总线协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/总线协议/"}]},{"title":"STM8复位(reset)","slug":"STM8-REST","date":"2016-08-08T14:12:15.000Z","updated":"2016-08-08T08:38:33.102Z","comments":true,"path":"2016/08/08/STM8-REST/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/08/STM8-REST/","excerpt":"","text":"一款芯片，复位的重要性我认为不亚于其他任何一个单元模块。同时，开发固件时，对芯片的复位条件、复位源、复位后的系统状态的掌握直接决定后面系统工作的可靠性。 复位源STM8复位源总共是6类，除了外部复位管脚提供的两种复位源(NRST和SWIM REST)，还有上下电(POR\\PDR)复位、独立看门狗(IWDG)复位、窗口看门狗(WWDG)复位、非法配置选项复位(ILLOP)。STM8的用户指南里对各个部分的外设的复位状态有明确的说明，例如大部分IO口复位之后都是浮动输入模式，但也有少数例外，使用时应该时刻注意复位状态对系统可能的影响。 复位状态与正在复位状态当复位源触发芯片复位后，芯片将进入一个复位期，这段时间里，芯片处在正在复位状态，完成硬件的初始化(默认复位状态),随后将跳转到复位向量处。在正在复位状态下，因为硬件可能没有复位到”复位状态”，一些管脚的状态值可能会和手册中的”复位值”不同。 复位管脚NRST当这个管脚上出现一个不低于300ns的低电平时，将产生复位新号。这个管脚同时可以当做普通IO来使用，以此来提高可利用IO口数量。处于安全考虑，通过向RTS_CR寄存器写入0xD0将复位管家配置成O口，只在复位之后得第一次设置时有效。 上下电(POR\\PDR)复位当系统电源VDD上的电压从工作电压跌至低于下电阈值时产生下电复位，反之产生上电复位。并且在复位寄存器RST_SR中置起相应标志位。 窗口看门狗(WWDG)复位这个看门狗必须在窗口内喂狗，否则当计数器减至0x3F时产生内部复位。 独立看门狗(IWDG)复位减计数看门狗，设定的时间间隔内不喂狗，产生复位新号。 以上只是一些简单的概要，详细细节见 STM8L 用户指南","categories":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/STM8/"}],"tags":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM8/"}]},{"title":"STM8内存(memory)","slug":"STM8-Memory","date":"2016-08-08T10:12:15.000Z","updated":"2016-08-08T08:36:21.251Z","comments":true,"path":"2016/08/08/STM8-Memory/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/08/STM8-Memory/","excerpt":"","text":"以低密度flash内存分配为例(高密度和中等密度只是内存分配及大小不同)，下图是内存映射图。 和51单片机一样，STM8也是8位机16位地址总线宽度，设计最大寻址范围也是64Kb，每页128字节，IAP操作以页为单位。整个FLASH被分为数据EEPROM(DATA EEPROM)、配置选项(OPTION BYTES)、代码区(CODE FLASH)。 数据EEPROM(DATA EEPROM)数据EEPROM可以用来存储一些应用数据，如软件版本号、公司或者组织信息、作者信息等等。初始时，为了保证数据安全，在IAP模式下这部分是写保护的。写保护可以通过MASS密码序列解除，此时可向EEPROM中写入数据。 主程序代码区在UBC或者私有代码区(PCODE)里的程序执行完后跳转到存储在这里执行代码。这里一般存的是用户代码。 配置选项(OPTION BYTES)这部分存储的是硬件配置代码，以字节为单位。主要会影响到硬件配置和内存的写保护。这部分的内容可以通过编程器在ICP条件下或者用户代码在IAP条件下改写，UBC与PCODE不可以更改这部分内容。 用户启动代码区(UBC)这个区域里包含用户IAP升级程序和各类中断向量，芯片在复位时会从RESET中断跳转到执行bootloader代码(这部分代码ST官方提供，用户也可以编写自己的bootloader)。UBC无法通过IAP改写，因为UBC拥有一个更强的二级写保护，这个写保护无法通过MASS密码序列解锁。因此更改这部分的代码只能通过ICP模式(使用 SWIM 接口)。通过配置选项(OPTION BYTES)，可以设置UBC的大小(以页为单位)。 私有代码区(PCODE)这部分不是所有型号的STM8芯片都存在的，具体是否有这部分，请参阅所使用芯片的datesheet。PCODE用来存放一些用以驱动硬件的私有代码库。可以在ICP模式下通过PCODESIZE配置选项配置其打下，一旦配置完成无法擦除，相应的PCODE区的大小也就固定不可更改了。 以上只是一些简单的概要，详细细节见 STM8L 用户指南","categories":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/STM8/"}],"tags":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM8/"}]},{"title":"STM8时钟系统(clock)","slug":"STM8-CLOCK","date":"2016-08-05T14:12:15.000Z","updated":"2016-08-19T08:07:09.489Z","comments":true,"path":"2016/08/05/STM8-CLOCK/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/05/STM8-CLOCK/","excerpt":"","text":"STM8时钟结构(clock structure) 时钟分类STM的时钟设计同时兼顾系统的鲁棒性及低功耗，共提供四类时钟,分别为高速外部时钟HSE、高速内部时钟HSI、低速内部时钟LSI、低速外部时钟LSE。 高速外部时钟HSE可由以下两个时钟源产生: 外部晶体/陶瓷振荡器 外部用户时钟源（byPass）在外部晶体震荡稳定下来之后外部时钟寄存器CLK_ECKCR中的HSERDY标志位会由硬件置位，用户可查询该标志位判断HSE的状态，另外可通过HSEON位控制HSE的开关。 高速内部时钟HSI HSI由内部集成的RC振荡器产生的16MHz频率。在系统启动时，由硬件自动将系统时钟源切换为HSI的8分频，也就是系统起始时钟频率为8MHz。HSI具有低功耗、快速的起振时间的特性，但是相比由外部晶体提供时钟源的HSE，精度稍差。 HSI在出厂时是完成过校准的，用户也可以通过CLK_HSICALR寄存器校准HSI。 HSI另外一个特点是作为备用时钟源，当CSS(clock security system)检测到HSE晶体停振，会自动将系统时钟切换到HSI，已保证系统的稳定运行。当设置了FHWU快速唤醒功能时，MCU在从停止状态唤醒时会自动切换到HSI完成快速唤醒。 低速外部时钟LSE由外接32768Hz的时钟源提供，主要为RTC提供高精度时钟源。 低速内部时钟LSILSI提供38KHz的时钟频率，可以在活跃停机下保持运行，给独立看门狗提供时钟频率。 CSS对于工业级产品，对稳定性要求很高，STM8的时钟机制可以提高系统的鲁棒性。CSS在HSE作为系统时钟时会一直处在监控状态，一旦HSE失效，硬件会自动切换到HSI，系统时钟分频系数不变。用户可以通过CSSEN设置CSS使能，一旦设置使能，知道系统复位，CSS将一直存在使能的状态且不可关闭。 时钟中断时钟控制器可以在一定条件下产生如下中断和事件 以上只是简单的概要，详细细节见 STM8L 用户指南","categories":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/STM8/"}],"tags":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM8/"}]},{"title":"UART","slug":"UART","date":"2016-08-05T10:12:15.000Z","updated":"2016-08-16T08:18:15.647Z","comments":true,"path":"2016/08/05/UART/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/05/UART/","excerpt":"","text":"通用异步收发器(UART)是嵌入式应用中最为常见的一中”总线协议”，之所以将UART归为总线协议中的一种，是因为广义上来讲，它规定了通信双方需要遵循的数据速率、通信格式等规则。即使它很简单，但是因为应用广泛，所以还是很值得去了解UART的相关特点以及实际应用中的一些注意点。 发送与接收UART将字节数据已一个个独立的位按照连续的方式发出，接收方已同样的方式接收并组成原字节数据，发送方与接收方都包含一个移位寄存器(shift register)用来将数据”串行化”或”反串行化。根据通信方式，UART可以分为单工、半双工、双工通信三类。 数据构成UART发送或接收的数据结构：起始位 + 数据位 + 校验位 + 停止位，其中除校验位可选外，其它都是必须项。 空闲模式当总线出于空闲模式时，发送端需要保持高电平，这是电报的历史遗留(保持高电平用以指示通讯线或收发器没有遭到破坏)。这在利用GPIO软件模拟UART的时候尤其需要注意，如果忽略会导致通信无法实现 起始位每次通信总是已一个逻辑”0”的bit开始，称为起始位。因为在空闲模式总线处于逻辑”1”，当起始位出现时，会产生一个下降沿，容易用来产生唤醒终端，通知接收方即使处理接下来发送的数据。 数据位数据位从5到9位不等，根据实际应用决定，大部分选择8位数据位，即一个字节。 校验位这是可选项，分为奇校验、偶校验、空格校验、标记校验等。奇校验保证数据位与校验位中的”1”的总数为奇数，偶校验则相反。至于空格校验则是校验位为”0”,标记校验为”1”。 停止位与起始位作用相反，标识通信结尾，为逻辑”1”。","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/总线协议/"}],"tags":[{"name":"UART","slug":"UART","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/UART/"}]},{"title":"STM8通用IO(GPIO)","slug":"STM8-GPIO","date":"2016-08-04T13:12:15.000Z","updated":"2016-08-05T07:35:16.391Z","comments":true,"path":"2016/08/04/STM8-GPIO/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/04/STM8-GPIO/","excerpt":"特性 每个IO口可单独配置 输入模式可配：上拉输入、悬浮输入 输出模式可配：推挽输出、开漏输出 输入输出数据寄存器独立 外部中断独立使能 输出斜率可控用以减小EMC噪声 管脚复用 1.6V-VddioMax直接IO状态稳定","text":"特性 每个IO口可单独配置 输入模式可配：上拉输入、悬浮输入 输出模式可配：推挽输出、开漏输出 输入输出数据寄存器独立 外部中断独立使能 输出斜率可控用以减小EMC噪声 管脚复用 1.6V-VddioMax直接IO状态稳定 相关寄存器(Register)主要是6个寄存器DDR、CR1、CR2、ODR、IDR,全部为8位一个字节，每一位对应一个IO口。 DDR(date direction register)控制IO口输入输出方向，0-输入模式，1-输出模式。 CR1(port control register #1) 输入模式 0：悬浮输入 1：输入上拉 输出模式 0：伪开漏输出 1：推挽输出，输出斜率可调(CR2) CR2(port control register #2) 输入模式 0：外部中断禁止 1：外部中断使能 输出模式 0：输出最大速率2MHz，低速模式 1：输出最大速率10MHz，高速模式 ODR(output date register)输出寄存器，忘改寄存器写入数据，可改变输出管脚电平状态。 IDR(input date register)输入寄存器，读取该寄存器可得到当前管脚电平状态。 以上只是简单的概要，详细细节见 STM8L 用户指南","categories":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/STM8/"}],"tags":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM8/"}]},{"title":"STM8概述","slug":"STM8-Summarize","date":"2016-08-04T11:32:15.000Z","updated":"2016-08-08T08:05:27.463Z","comments":true,"path":"2016/08/04/STM8-Summarize/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/04/STM8-Summarize/","excerpt":"","text":"特性 电源电压范围：1.8V-3.6V 低功耗： 五种低功耗模式 动态功耗：与时钟频率相关 200uA/MHz+330uA IO漏电流：50nA 从停止模式唤醒仅需4.7uS 先进的STM8内核 哈佛结构 可达到16MIPS 多达40个外部中断源 丰富的外设 DMA LCD RTC ADC TIMER CLOCK MANAGEMENT … GPIO REST CLOCK Memory 以上只是一些我认为是重点的部分的简单的概要，很多操作都可以通过ST公司提供的库函数完成，这些库函数结构合理使用方便，用户完全可以拿过来使用，因此很多操作的细节了解下就好了，出了BUG知道一个方向去解决，其他的交给库函数吧。详细细节见 STM8L 用户指南","categories":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/STM8/"}],"tags":[{"name":"STM8","slug":"STM8","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/STM8/"}]},{"title":"M-Bus和DLT645-2007通讯协议","slug":"MBusAndDTL645","date":"2016-08-03T15:12:15.000Z","updated":"2016-08-03T07:54:37.489Z","comments":true,"path":"2016/08/03/MBusAndDTL645/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/03/MBusAndDTL645/","excerpt":"","text":"M-Bus(meter-bus)是一个专用于公共事业仪表的总线结构，《DL/T645-2007多功能电能表通信协议》是发改委发布的一项用于国内电能表数据通信的协议规范，相当于MBus的”汉化版”。 MBus总线协议帧格式|–前导字节–|–帧起始符–|–仪表类型–|–从站地址域–|–控制码–|–数据长度–|–数据域–|–纵向校验码–|–帧结束–|字节格式：8位数据位+1个起始位+1个奇偶校验位+1停止位。传输时，低位在前，高位在后。 前导字节通信前设备发送一定数目的FEH,本质上是物理层的要求，用于唤醒设备和同步，一般是2~4个FE。 帧起始符表示一帧信息的开始，为68H。 仪表类型指示参与通信的从站是那种类型的计量仪表: 10H~19H: 水表 20H~29H: 热表 30H~39H: 燃气表 地址域地址域指示与之通信的从站的地址，由7个字节组成A0A1A2A3A4A5A6,每个字节为2为BCD码，其中A5A6为厂商代码，低地址在前高地址在后，AAH为通配地址，当为AAAAAAAAAAAAAA时，代表广播。 控制码帧信息控制代码，一个字节，字节的低6位代表相应信息的控制码（如000100代表读计量数据），第7位表示从站应答信息（0-正确应答，1-异常信息的应答），第8位表示帧的发送方（0-主站的控制帧，1-从站应答帧）。 数据长度数据域的数据长度。 数据域数据，含义根据控制码及上下文确定。发送方进行加33H处理，接收方进行减33H处理。 纵向校验码从帧起始符开始到校验码之前得所有字节的二进制算术累加和，无进位。 帧结束符表示一帧信息的结束，为68H。 数据传输 所有多字节数据域（地址域、数据域）均先传送地位后高位，例如传输数据0x12345678,先发送数据0x78,依次发送0x56、0x34、0x12。 通讯为半双工通信，每次通信均为主站请求、从站应答。 字节奇偶校验错误、帧校验错误都代表数据通信异常，丢弃信息帧。 最长响应时间为Tr = 50ms + 30 * Tbyte,其中Tbyte为传输一个字节所需时间。","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/总线协议/"}],"tags":[{"name":"MBus DL/T645-2007 电能表通信协议","slug":"MBus-DL-T645-2007-电能表通信协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/MBus-DL-T645-2007-电能表通信协议/"}]},{"title":"SPI","slug":"SPI","date":"2016-08-03T10:12:15.000Z","updated":"2016-09-14T05:16:54.062Z","comments":true,"path":"2016/08/03/SPI/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/08/03/SPI/","excerpt":"","text":"参考链接: wikipedia SPI I2C SPI与I2C总线类似，不同的是I2C是半双工，SPI是全双工的数据总线。 SPI采用四线制： 1234SCLK（Serial Clock）：串行时钟，由主机发出MOSI（Master Output,Slave Input）：主机输出从机输入信号，由主机发出MISO（Master Input,Slave Output）：主机输入从机输出信号，由从机发出SS（Slave Selected）：片选信号，由主机发出，低电平有效 与I2C类似，沿接收、沿发送，高低位时数据线保持稳定。 I2C采用发送数据中包含地址信息来选择从设备，SPI使用片选信号来选择从设备，因此从标准上来看，I2C比SPI的从设备选择更加灵活。 使用SPI时，需要明确总线时钟极性与相位。根据实际外设需求设置。","categories":[{"name":"总线协议","slug":"总线协议","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/总线协议/"}],"tags":[]},{"title":"如何合理命名你的代码","slug":"howToNameYourCode","date":"2016-07-28T15:01:20.000Z","updated":"2016-09-14T03:06:54.362Z","comments":true,"path":"2016/07/28/howToNameYourCode/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/28/howToNameYourCode/","excerpt":"文中内容参考自Bob Nystrom的blog。原文链接","text":"文中内容参考自Bob Nystrom的blog。原文链接 A name has two goals: - It needs to be clear: you need to know what the name refers to. - It needs to be precise: you need to know what it does not refer to. 遵循最简洁、精确的命名原则省略那些从变量类型上就可以得知的信息这个规则主要用在使用静态类型的语言上，用户(程序员)通常知道一个变量的类型，那么如果此时再在变量的命名中添加关于变量类型的信息无疑是冗余的(不是很赞同，如果是嵌入式开发者，尤其是从事单片机应用开发的程序员，现如今使用的大部分IDE或代码编辑工具对变量的自动补全、提示都支持的不够友好，例如keil。在处理一些变量的时候，知道变量的类型会让程序员知道这个变量占用的内存大小、存放位置，从而更好的去使用它。)1234567// Bad:String nameString;DockableModelessWindow dockableModelessWindow;// Better:String name;DockableModelessWindow window; 省略那些容易产生歧义的信息这点在我以往的命名中是个普遍存在的毛病，例如，声明一个用于存储文件路径的变量，我会命名为string currentUsedFilePath,虽然在一定程度上达到了变量名的自解释的作用，但是会让其他阅读你的程序的人产生误解，到底是current Used File`s Path，还是current Used FilePath(@_@);1234567// Bad:finalBattleMostDangerousBossMonster;weaklingFirstEncounterMonster;// Better:boss;firstMonster; 省略那些在当前的上下文中可以得到的信息这点很好理解，比如你的项目中只用到LCD来完成显示相关信息，用来刷新显示的函数直接命名display和你命名LCDDisplay是一个效果的，但是后者显得会有些冗余，同样，类的成员命名也是一个道理；1234567891011// Bad:class AnnualHolidaySale &#123; int _annualSaleRebate; void promoteHolidaySale() &#123; ... &#125;&#125;// Better:class AnnualHolidaySale &#123; int _rebate; void promote() &#123; ... &#125;&#125; 抛弃那些意义不大的信息一个原则：试想，如果去掉这部分信息，这个命名的意义变化了吗？如果没有，果断去掉，例如声明一个变量 int tempVariable;,去掉variable吧！12345678// bad class WaffleObject &#123; void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;&#125;// good oneclass Waffle &#123; void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/C/"}],"tags":[{"name":"C 软件","slug":"C-软件","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/C-软件/"}]},{"title":"升级助手上位机（使用C#编写）","slug":"updateAssistant","date":"2016-07-26T16:33:21.000Z","updated":"2016-09-14T03:07:50.866Z","comments":true,"path":"2016/07/27/updateAssistant/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/27/updateAssistant/","excerpt":"","text":"bootloader写完之后，使用C#写了一个配套的升级助手。不得不说C#真的是一个很优秀的语言，而visual studio也完全可以称之为最强IDE，没有之一！配合MSDN，花了一个星期熟悉C#,然后两周不到完成了51升级助手的开发。 主界面 特点: 支持多种不同的通信协议（主要用于升级前的握手） 用户自定义协议 IEC62056-21 C模式 DL/T645-07 配合51bootloader完成用户代码的更新 支持原生Intel HEX-80格式 支持设定用户代码段地址范围 支持自动重发 自动剔除全0xFF数据，减少发送数据量 使用到的功能模块:1.串口通信(使用C#官方serialPort类库);2.文件读写(使用C#官方File类库);3.设置文件(使用xml保存);4.定时器(用于通信时序控制); 整体思路首先上位机升级助手打开本地hex文件，对hex文件进行格式化，方便后面的数据传输。然后下位机在接收到升级指令后会判断是否符合升级条件，如果符合，则跳转到bootloader程序中准备接收升级数据，否则忽略升级指令，并返回响应帧通知上位机。在升级的过程中，双方遵循同一个校验算法，下位机校验数据通过，通过IAP写入flash，否则请求重发。下位机检测到处理到用户代码段的最后一帧数据，发送升级完成指令，下位机接收校验通过，通过长跳转指令调到用户代码，完成程序升级。因为下位机bootloader采用查询的方式通信，为了提高可靠信，及降低出错时的重传代价，一次传输的代码字节限制在16个字节，所以需要格式化hex-80文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private bool handleHexFile(string filePath)&#123; string[] Hex=System.IO.File.ReadAllLines(filePath); string[] formatHex= System.IO.File.ReadAllLines(Application.StartupPath + \"\\\\tempHexFile.txt\"); uint dateAddr = 0; uint dateLen = 0; foreach (string hexLine in Hex) &#123; if (!string.IsNullOrEmpty(hexLine)) &#123; if (hexLine.Substring(0, 1) == \":\") // hex-80文件以冒号\":\"开头 &#123; dateLen = Convert.ToUInt32(hexLine.Substring(1,2).Trim(),16); dateAddr = Convert.ToUInt32(hexLine.Substring(3, 4).Trim(),16); if (dateLen == 0) &#123; continue; &#125; uint modLine = dateAddr / 16; uint modByte = dateAddr % 16 + 1; uint modLen = dateLen; string[] tempStr=null; tempStr = formatHex[modLine].Trim().Split(' '); for (int i = 0; i &lt; modLen*2; i+=2) &#123; tempStr[modByte] = hexLine.Substring(9 + i, 2).Trim(); if (modByte&gt;=16) &#123; string temp = null; for (int n = 0; n &lt; tempStr.Length; n++) &#123; temp += (tempStr[n].TrimStart() + ' '); &#125; formatHex[modLine] = temp; modByte = 0; modLine++; tempStr = formatHex[modLine].Trim().Split(' '); &#125; modByte++; &#125; string temp2 = null; for (int n = 0; n &lt; tempStr.Length; n++) &#123; temp2 += (tempStr[n].TrimStart() + ' '); &#125; formatHex[modLine] = temp2; &#125; else &#123; tbInformation.AppendText(\"empty\"); return false; &#125; &#125; &#125; updateFile = formatHex; System.IO.File.WriteAllLines(Application.StartupPath + \"\\\\HexFile.txt\", formatHex); return true;&#125; 除此之外，根据通信协议完成通讯部分的代码设计，一个可用的升级助手基本完成。","categories":[{"name":"C#","slug":"C","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/C/"}],"tags":[{"name":"C# 上位机 串口","slug":"C-上位机-串口","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/C-上位机-串口/"}]},{"title":"ASCII码表","slug":"ASCII","date":"2016-07-21T11:23:14.000Z","updated":"2016-08-01T05:43:25.175Z","comments":true,"path":"2016/07/21/ASCII/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/21/ASCII/","excerpt":"","text":"This table lists the ASCII characters and their decimal, octal and hexadecimal numbers. Characters which appear as names in parentheses (e.g., (nl)) are non-printing characters. A table of the common non-printing characters appears after this table. Char Dec Oct Hex | Char Dec Oct Hex | Char Dec Oct Hex | Char Dec Oct Hex ------------------------------------------------------------------------------------- (nul) 0 0000 0x00 | (sp) 32 0040 0x20 | @ 64 0100 0x40 | ` 96 0140 0x60 (soh) 1 0001 0x01 | ! 33 0041 0x21 | A 65 0101 0x41 | a 97 0141 0x61 (stx) 2 0002 0x02 | \" 34 0042 0x22 | B 66 0102 0x42 | b 98 0142 0x62 (etx) 3 0003 0x03 | # 35 0043 0x23 | C 67 0103 0x43 | c 99 0143 0x63 (eot) 4 0004 0x04 | $ 36 0044 0x24 | D 68 0104 0x44 | d 100 0144 0x64 (enq) 5 0005 0x05 | % 37 0045 0x25 | E 69 0105 0x45 | e 101 0145 0x65 (ack) 6 0006 0x06 | &amp; 38 0046 0x26 | F 70 0106 0x46 | f 102 0146 0x66 (bel) 7 0007 0x07 | ' 39 0047 0x27 | G 71 0107 0x47 | g 103 0147 0x67 (bs) 8 0010 0x08 | ( 40 0050 0x28 | H 72 0110 0x48 | h 104 0150 0x68 (ht) 9 0011 0x09 | ) 41 0051 0x29 | I 73 0111 0x49 | i 105 0151 0x69 (nl) 10 0012 0x0a | * 42 0052 0x2a | J 74 0112 0x4a | j 106 0152 0x6a (vt) 11 0013 0x0b | + 43 0053 0x2b | K 75 0113 0x4b | k 107 0153 0x6b (np) 12 0014 0x0c | , 44 0054 0x2c | L 76 0114 0x4c | l 108 0154 0x6c (cr) 13 0015 0x0d | - 45 0055 0x2d | M 77 0115 0x4d | m 109 0155 0x6d (so) 14 0016 0x0e | . 46 0056 0x2e | N 78 0116 0x4e | n 110 0156 0x6e (si) 15 0017 0x0f | / 47 0057 0x2f | O 79 0117 0x4f | o 111 0157 0x6f (dle) 16 0020 0x10 | 0 48 0060 0x30 | P 80 0120 0x50 | p 112 0160 0x70 (dc1) 17 0021 0x11 | 1 49 0061 0x31 | Q 81 0121 0x51 | q 113 0161 0x71 (dc2) 18 0022 0x12 | 2 50 0062 0x32 | R 82 0122 0x52 | r 114 0162 0x72 (dc3) 19 0023 0x13 | 3 51 0063 0x33 | S 83 0123 0x53 | s 115 0163 0x73 (dc4) 20 0024 0x14 | 4 52 0064 0x34 | T 84 0124 0x54 | t 116 0164 0x74 (nak) 21 0025 0x15 | 5 53 0065 0x35 | U 85 0125 0x55 | u 117 0165 0x75 (syn) 22 0026 0x16 | 6 54 0066 0x36 | V 86 0126 0x56 | v 118 0166 0x76 (etb) 23 0027 0x17 | 7 55 0067 0x37 | W 87 0127 0x57 | w 119 0167 0x77 (can) 24 0030 0x18 | 8 56 0070 0x38 | X 88 0130 0x58 | x 120 0170 0x78 (em) 25 0031 0x19 | 9 57 0071 0x39 | Y 89 0131 0x59 | y 121 0171 0x79 (sub) 26 0032 0x1a | : 58 0072 0x3a | Z 90 0132 0x5a | z 122 0172 0x7a (esc) 27 0033 0x1b | ; 59 0073 0x3b | [ 91 0133 0x5b | { 123 0173 0x7b (fs) 28 0034 0x1c | &lt; 60 0074 0x3c | \\ 92 0134 0x5c | | 124 0174 0x7c (gs) 29 0035 0x1d | = 61 0075 0x3d | ] 93 0135 0x5d | } 125 0175 0x7d (rs) 30 0036 0x1e | &gt; 62 0076 0x3e | ^ 94 0136 0x5e | ~ 126 0176 0x7e (us) 31 0037 0x1f | ? 63 0077 0x3f | _ 95 0137 0x5f | (del) 127 0177 0x7f ASCII Name Description C Escape Sequence nul null byte \\0 bel bell character \\a bs backspace \\b ht horizontal tab \\t np formfeed \\f nl newline \\n cr carriage return \\r vt vertical tab esc escape sp space","categories":[{"name":"others","slug":"others","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/others/"}],"tags":[{"name":"ASCII","slug":"ASCII","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/ASCII/"}]},{"title":"C#学习笔记","slug":"CSharp","date":"2016-07-18T18:58:10.000Z","updated":"2016-08-02T08:09:13.067Z","comments":true,"path":"2016/07/19/CSharp/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/19/CSharp/","excerpt":"","text":"C#关键字 &gt;abstract可以和类、方法、属性、索引器及事件一起使用，标识一个可以扩展但不能被实体化的、必须被实现的类或方法。 &gt;as一个转换操作符，如果转换失败，就返回null。 &gt;base用于访问被派生类或构造中的同名成员隐藏的基类成员。 &gt;catch定义一个代码块，在特定类型异常抛出时，执行块内代码。参见try和finally。 &gt;checked既是操作符又是语句。确保编译器运行时，检查整数类型操作或转换时出现的溢出。 &gt;const标识一个可在编译时计算出来的变量值，即一经指派不可修改的值。 &gt;delegate指定一个声明为一种委托类型。委托把方法封装为可调用实体，能在委托实体中调用。 &gt;enum表示一个已命名常量群集的值类型。 &gt;event允许一个类或对象提供通知的成员，他必须是委托类型。 &gt;explicit一个定义用户自定义转换操作符的操作符，通常用来将内建类型转换为用户定义类型或反向操作。必须再转换时调用显示转换操作符。 &gt;extern标识一个将在外部（通常不是c#语言）实现的方法。 &gt;finally定义一个代码块，在程序控制离开try代码快后执行。参见try和catch。 &gt;fixed在一个代码块执行时，在固定内存位置为一个变量指派一个指针。 &gt;foreach用于遍历一个群集的元素。 &gt;goto一个跳转语句，将程序执行重定向到一个标签语句。 &gt;implicit一个操作符，定义一个用户定义的转换操作符。 通常用来将预定义类型转换为用户定义类型或反向操作。隐式转换操作符必须在转换时使用。 &gt;interface将一个声明指定为接口类型，即实现类或构造必须遵循的合同。 &gt;internal一个访问修饰符。 &gt;namespace定义一个逻辑组的类型和命名空间。 &gt;operator用来声明或多载一个操作符。 &gt;out标识一个参数值会受影响的参数，但在传入方法时，该参数无需先初始化。 &gt;params声明一个参数数组。如果使用，必须修改指定的最后一个参数。允许可选参数。 &gt;readonly标识一个变量的值在初始化后不可修改。 &gt;ref标识一个参数值可能会受影响的参数。 &gt;sealed防止类型被派生，防止方法和property被覆载。 &gt;sizeof一个操作符，以byte为单位返回一个值类型的长度。 &gt;stackalloc返回在堆上分配的一个内存块的指针。 &gt;structstruct是一种值类型，可以声明常量、字段、方法、property、索引器、操作符、构造器和内嵌类型。 &gt;throw抛出一个异常。 &gt;try异常处理代码块的组成部分之一。try代码块包括可能会抛出异常的代码。参阅catch和finally关键字。 &gt;typeof一个操作符，返回传入参数的类型。 &gt;unchecked禁止溢出检查。 &gt;unsafe标注包含指针操作的代码块、方法或类。 &gt;using当用于命名空间时，using关键字允许访问该命名空间中的类型， 而无需指定其全名。也用于定义finalization操作的范围。 &gt;virtual一个方法修饰符，标识可被覆载的方法。 &gt;volatile标识一个可被操作系统、某些硬件设备或并发线程修改的attribute。 与C/C++的区别 C#中没有全局函数声明在类型声明的外部，方法也没有默认的返回类型，必须包含返回类型或void.","categories":[{"name":"C#","slug":"C","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/C/"}],"tags":[{"name":"C#学习笔记","slug":"C-学习笔记","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/C-学习笔记/"}]},{"title":"关于keil和C的那些杂乱知识点","slug":"Keil&C","date":"2016-07-14T14:47:14.000Z","updated":"2016-08-03T02:29:25.744Z","comments":true,"path":"2016/07/14/Keil&C/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/14/Keil&C/","excerpt":"最近在做bootloader的时候，对51的存储及架构和keil的使用有了更深入的了解，由于知识点比较杂乱，先记录下来，后期再整理。","text":"最近在做bootloader的时候，对51的存储及架构和keil的使用有了更深入的了解，由于知识点比较杂乱，先记录下来，后期再整理。 在bootloader程序与用户程序之间跳转的时候使用LJMP长跳转指令而不是LCALL长调用指令。原因在于，如果使用长调用，会导致函数的嵌套甚至是递归，这显然不符合正常处理逻辑。 成为一个合格的嵌入式软件开发者掌握C的使用基本上就可以了，但是想要更深入点，去对处理器有个更深入的了解和认识，不会汇编语言是一件很痛苦的事情。 startup.A51可以在用户代码运行之前完成数据空间、栈空间的初始化。合理使用并根据实际项目需求区修改，可以实现些期望在用户代码执行之前完成的操作，比如作为全局变量的数据的初始化。 typedef void (code*USERAPP)(void); 定义一个函数返回值和形参都是void的函数指针，使用效果同LCALL #funAddr。 因为IAP的操作必须响应相应中断，否则会导致MCU无限挂起，因此需要将所有的中断都进行绝对定位，并且中断向量所在的第一页不能擦除（如果擦除会导致如果升级失败会导致无法再次进入bootloader）。 我现在使用的V9821存在十几个中断向量，如果一个个在keil的BL51 Locate增加绝对地址的链接，会很麻烦也会容易出错，这点需要寻求其他更方便的解决方法，比如增加一个专门用于绝对定位的A51文件。 未完待续 对于多个函数的绝对地址链接在keil中实现起来比较麻烦，在仔细研究过keil工程后发现，keil的后缀为.uvproj的工程文件实际上是一个xml文件，里面&lt;CodeSegmentName&gt;标签所保存的就是BL51 Locate选项卡中添加的绝对定位信息，修改这个标签的内容同样可以达到同样的目的。 M51文件是keil生成的内存布局文件，在设计bootloader程序时尤其有用。","categories":[{"name":"C","slug":"C","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/C/"}],"tags":[{"name":"keil C","slug":"keil-C","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/keil-C/"}]},{"title":"bootloader使用注意事项","slug":"bootloader-Caution","date":"2016-07-13T17:53:26.000Z","updated":"2016-09-14T03:05:25.490Z","comments":true,"path":"2016/07/14/bootloader-Caution/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/14/bootloader-Caution/","excerpt":"keil 链接选项","text":"keil 链接选项 123456789101112131415161718// 全局设置#define D_FLAGADDR 0xFFF0 // 存储全局升级标志（可选）#define D_MCU D_V98XX // MCU类型#define D_FRAMELEN 16 // 每帧的数据长度#define D_ADRESSMODE D_ABSOLUTE // 寻址模式#define D_READCHECK D_FALSE // 读出比对#define D_TIMETH (30) // *50ms// note* bootloader位于flash中的最后10k_(10或20页)(0xD800-0xFFFF),其中0xFE00页用于保存用户程序的入口地址#if (D_MCU == D_V98XX) #define D_SECTORSUM 0x6c // 128-20页 #define D_SECTORSIZE 0x200 // 每页大小，V98xx是512个字节 中颖7012是1024个字节#endif#if (D_MCU == D_SH7012) #define D_SECTORSUM 0x36 // 64-10页 #define D_SECTORSIZE/ 0x400 // 每页大小，V98xx是512个字节 中颖7012是1024个字节#endif#define D_FRAMENUM (D_SECTORSIZE/D_FRAMELEN) // 传输一页数据需要的总帧数 其中D_FLAGADDR是作为升级标志的全局标志位，位于xdata区，在用户程序接受到升级指令后需要将该位置写入数据0x55。后续增加对IO口的支持。 关于中断处理 由于IAP的机制要求中断进行响应，而C51程序中的代码首页放置的就是STARTUP与各个中断入口的地址，一旦对首页0000-0200的512字节进行擦除或者写操作，就会导致IAP中断无法响应MCU一直处于挂起状态，所以为了避免这种情况必须保证首页不被擦除或改写，因此提前将中断入口地址固定，保证后面升级的程序中断入口地址不变。否则中断程序的跳转将指向错误的地址，同时为每个中断函数预留了一定的空间，方便用户添加简单的中断处理代码。 为了实现这点，必须将IAP所在的中断进行中断跳转处理，这会导致中断在响应的时候会慢至少一个LJMP指令，但是对于目前主频达到十几兆的增强型51来说是可以忽略不计的。 如何实现因为IAP中断不可擦出，中断服务函数同样应该位于不可擦出段，因此可将该段代码定位在bootloader代码的开始。在IAP中断服务函数中跳转至中断映射代码，同样中断映射代码的函数地址同样需要固定，但是是可擦出的。 0x0000-0x03FF: 中断向量表 0x0400-0x05FF: 512字节的出厂参数，单片机正常工作所必须的参数，不用于用户代码。 0x0600-0xD4FF: 用户代码 0xD500-0xD6FF: 中断映射代码 0xD700-0xD7FF: 启动代码 0xD800-0xFFFF: bootloader代码 中断服务函数绝对定位地址1234567891011 EXINT0SEG =0xC500-0xC5FF TIMER0SEG =0xC600-0xCBFF EXINT1SEG =0xCC00-0xCCFF TIMER1SEG =0xCD00-0xCDFF TIMER2SEG =0xCE00-0xCEFF UART1SEG =0xCF00-0xD1FF*UARTCFSEG =0xD200-0xD3FF UARTRTCSEG =0xD400-0xD4FF PLLEXINT3SEG =0xD500-0xD5FF TIMERASEG =0xD600-0xD6FF POWERSEG =0xD700-0xD7FF 其中，UARTCFSEG实际并不是由中断向量直接指向，而是中断服务函数的一个子函数，因为UARTCF中断包含IAP中断，所以这部分的代码处在不可擦除区。 非常重要的一点因为bootloader是和用户代码放在同一个工程下，对于常量尤其是函数内部的字符串常量，编译器在编译的时候可能会把这部分常量放进用户代码区，导致升级之后这部分变量会被更改。解决方法： 尽量少使用常量尤其是字符串常量 bootloader代码中使用的所有变量，不要使用默认初始值也不要使用声明的同时赋值的用法；","categories":[{"name":"bootloader","slug":"bootloader","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/bootloader/"}],"tags":[{"name":"嵌入式 单片机","slug":"嵌入式-单片机","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/嵌入式-单片机/"}]},{"title":"简易bootloader设计思路","slug":"simple-bootloader-for51","date":"2016-07-06T14:42:23.000Z","updated":"2016-08-01T05:43:25.146Z","comments":true,"path":"2016/07/06/simple-bootloader-for51/","link":"","permalink":"http://www.xn--4gqa63c686ta68iba.ren/2016/07/06/simple-bootloader-for51/","excerpt":"作为表计产品，限制于使用环境及产品制造特性（如超声波焊），通常在表计生产完成尤其是送到客户手中后，想要再升级固件程序，如果没有bootloader的支持，难度与代价都很大。因此，为现有平台所有系列的MCU添加bootloader程序是个刚性的需求。最近需要实现V9821的在线升级功能，研究了两天初步有了思路，接下来就是实现了，先记录下初步的思路。","text":"作为表计产品，限制于使用环境及产品制造特性（如超声波焊），通常在表计生产完成尤其是送到客户手中后，想要再升级固件程序，如果没有bootloader的支持，难度与代价都很大。因此，为现有平台所有系列的MCU添加bootloader程序是个刚性的需求。最近需要实现V9821的在线升级功能，研究了两天初步有了思路，接下来就是实现了，先记录下初步的思路。 实现bootloader的前提条件有： IAP功能 代码区足够大或存在外部flash 对于51单片机，最大支持64Kb的程序代码，其中包括中断向量、启动代码、用户代码、bootloader代码，因此需要合理分配flash空间。对于vango的V98xx系列单片机，程序存储区地址映射如下图: Flash存储器的008000h–01FFFFh的内容根据代码段选择寄存器CBANK,SFR 0xA0的配置，以32KB为单位，选择行的映射到程序存储器0x8000-0xFFFF区域。其中common area为公共代码区，使用时不需要切换Code Bank，默认代码段为Bank1。 使用时刻根据实际情况考虑是否使用bank switch技术，因为我用于验证的用户代码不大，加上bootloader程序也远达不到64Kb的代码量，因此不分bank。 Flash存储器空间分配 0x0000-0x03FF: 中断向量表 0x0400-0x05FF: 512字节的出厂参数，单片机正常工作所必须的参数，不用于用户代码。 0x0600-0xD5FF: 用户代码 0xD600-0xD7FF: 中断映射代码 0xD800-0xD8FF: 启动代码 0xD900-0xFFFF: bootloader代码 其中启动代码、bootloader均位于不可IAP区。0x000-0x03FF为不可IAP区域，硬件不支持 软件设计思路 上电复位：执行startup，跳转到bootloader代码； 在bootloader中首先检查升级指令是否存在[1]，如果不存在跳转到用户代码，反之执行升级 。 用户代码中也可被升级指令切换至bootloader程序； 等待数据（等待时长可设），超时复位到用户代码； 接收升级数据并校验[2]。 写入update[3]。 全部接收完成并校验通过，擦除用户代码，写入升级数据[4]。 note 可使用xdata区的固定位置的全局变量或者相关IO标志。 使用hex文件格式的校验方式：校验和 = 0x100 - 累加和 如果代码不超过32KB，直接写入update区。如果超过32KB，使用外部存储或者直接擦除用户代码，写入升级数据。 写入的时候以16个字节为一组写入。","categories":[{"name":"bootloader","slug":"bootloader","permalink":"http://www.xn--4gqa63c686ta68iba.ren/categories/bootloader/"}],"tags":[{"name":"嵌入式 单片机","slug":"嵌入式-单片机","permalink":"http://www.xn--4gqa63c686ta68iba.ren/tags/嵌入式-单片机/"}]}]}